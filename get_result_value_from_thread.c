#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

void* roll_dice()
{
	int	value = (rand() % 6) + 1;
	int* result = malloc(sizeof(int));//needed to repoint
	*result = value;
	//printf("%d\n", value); we do not use anymore
	printf("Thread result:%p\n", result);
	return (void*) result;
}

int	main(int ac, char* av[])
{
	int* res;
	srand(time(NULL));
	pthread_t	th;
	if (pthread_create(&th, NULL, &roll_dice, NULL) != 0)
		return (1);
	if (pthread_join(th, (void**) &res) != 0)
		return (2);
	printf("Result: %d\n", *res);
	printf("Main res:%p\n", res);
	free(res);
	return (0);
}

/*
"Thread result" and "Main res"
display the same memory address
because it is the result of malloc in the thread.
This address was passed back to the main function through the "pthread_join" mechanism.

 То, что адрес совпадает в вашем примере, связано с тем, что вы явно выделяете память с помощью malloc в одном потоке и передаёте её главному потоку через pthread_join. Однако это не означает, что потоки "автоматически" работают с одним и тем же адресом памяти.

Как работает память в потоках:
Локальная память
Каждому потоку выделяется собственный стек, и данные, которые поток размещает в своём стеке (например, локальные переменные), изолированы от других потоков.

Общая память
Все потоки в одном процессе имеют доступ к общим сегментам памяти, таким как:

Динамическая память, выделенная с помощью malloc или других подобных функций.
Глобальные и статические переменные.
Ваш случай
В вашем коде поток выделяет память через malloc, а затем возвращает указатель на эту память главному потоку. malloc выделяет память из общей кучи, доступной всем потокам. Таким образом, оба потока (создавший и главный) имеют доступ к одному и тому же адресу.

Многопоточность и доступ к одному адресу
Да, потоки могут работать с одним и тем же адресом памяти одновременно, если они разделяют общую память. Однако при этом важно учитывать:

Синхронизацию: Если несколько потоков читают и записывают данные по одному и тому же адресу, требуется синхронизация (например, с использованием мьютексов или других примитивов) для предотвращения гонок данных.
Безопасность: Если синхронизация отсутствует, это может привести к непредсказуемому поведению программы.*/